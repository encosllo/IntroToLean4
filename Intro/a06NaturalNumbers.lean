-- # Natural Numbers
import a05Functions
open Inj

-- The type of Natural Numbers `Nat`
#check Nat
#print Nat

-- Lean comes with the `Nat` type already
-- implemented, along with many theorems related
-- to natural numbers. However, to gain a deeper
-- understanding of how natural numbers can be
-- constructed and reasoned about, we will define
-- our own custom type, which we will call `N`
inductive N : Type where
  | z : N
  | s : N →  N
deriving Repr

#check N
#print N

-- According to our definition, we have defined
-- the structure (N, z, s), where `z`
-- (representing zero)  is an element of type `N`
-- and `s` (representing the successor) is a
-- function from `N` to `N`
#check N.z
#check N.s

-- To work with `N` without needing to prefix everything with `N.`,
-- we can open the namespace to bring its notation into scope
open N

#check z
#check s

-- ## Cases
-- Let's define a function from `N` to `Bool` by `cases`.
-- The function will compare an element of type `N` with zero
-- If they are equal, it will return `true`
-- If they are different, it will return `false`
def Eqzero : N → Bool := by
  intro n
  cases n
  -- Case zero
  exact true
  -- Case successor
  exact false

-- ## Match
-- We will define an alternative to `Eqzero`
-- using the keyword `match` for pattern matching
def Eqzero2 : N → Bool := by
  intro n
  match n with
    | z    => exact true
    | s _  => exact false

-- ## Injection
-- Note that the type `N` gives us a
-- Dedekind–Peano algebra. We can think of this
-- structure as the free algebra generated by a
-- constant `z` and a unary operation `s`.
-- In this setup, `z` can never be equal to
-- `s n` for any `n : N`.
theorem TZInj : ∀ {n : N}, z ≠ s n := by
  intro n
  intro h
  cases h

-- Similarly, the successor function `s` is
-- injective. For this we use the tactic
-- `injection` which states that constructors
-- of inductive data types are injective
theorem TSuccInj : injective s := by
  intro n m h
  injection h

-- ## noConfusion
-- We can also apply the `noConfusion` principle
theorem TSuccInjAlt : injective s := by
  intro n m h
  exact N.noConfusion h id

-- ## Induction
-- Let's prove some theorems about the type `N`.
-- The proofs will be carried out by **induction**.
-- The `induction` tactic can be used on any inductive type
theorem TInd {P : N → Prop} (h0 : P z) (hi : ∀ (n : N), P n → P (s n)) : ∀ (n : N), P n := by
  intro n
  induction n
  -- Base case: `z`
  exact h0
  -- Inductive step: assume the property holds for `n`,
  -- and prove it for `s n`
  rename_i n hn
  exact (hi n) hn

-- ## Recursion

-- ### Maximum
-- Recursive definition of the maximum of two natural numbers
def maxi : N → N → N := by
  intro n m
  match n, m with
    | z, m  => exact m
    | n, z  => exact n
    | s n', s m' => exact s (maxi n' m')

-- ### Minimum
-- Recursive definition of the minimumm of two natural numbers
def mini : N → N → N := by
  intro n m
  match n, m with
    | z, _  => exact z
    | _, z  => exact z
    | s n', s m' => exact s (mini n' m')

-- ### Addition
-- We define the addition of natural numbers recursively
-- Note that the recursion is on the first argument
def Addition : N → N → N := by
  intro n m
  cases n with
    | z   => exact m
    | s n => exact s (Addition n m)

-- Notation for Addition
notation : 65 lhs:65 " + " rhs:66 => Addition lhs rhs

-- ### Fibonacci
-- We define the Fibonacci function recursively
def Fib : N → N := by
  intro n
  match n with
    | z       => exact z
    | s z     => exact (s z)
    | s (s n) => exact n + (s n)

def four : N := s (s (s (s z)))
#eval Fib (four)

-- ### Multiplication
-- We define the multiplication of natural numbers recursively
-- Note that the recursion is on the first argument
def Multiplication : N → N → N := by
  intro n m
  cases n with
    | z   => exact z
    | s n => exact (Multiplication n m) + m

-- Notation for Multiplication
notation : 70 lhs:70 " * " rhs:71 => Multiplication lhs rhs

-- #### Factorial
-- We define the factorial function recursively
def Fact : N → N := by
  intro n
  cases n with
    | z   => exact (s z)
    | s n => exact (s n) * (Fact n)

def three : N := s (s (s z))
#eval Fact (three)

-- ## Decidable Equality
-- The recursive nature of `N` allows us to prove
-- that they have a decidable equality
def instDecidableEqN : DecidableEq N := by
  intro n m
  match n, m with
    | z, z        => exact isTrue  rfl
    | z, s _      => exact isFalse (by intro h; cases h)
    | s _, z      => exact isFalse (by intro h; cases h)
    | s n', s m'  =>
      match instDecidableEqN n' m' with
      | isTrue h  => exact isTrue (congrArg s h)
      | isFalse h => exact isFalse (fun h' => N.noConfusion h' (fun h'' => h h''))

namespace a06Exercises
-- Prove that no natural number is equal
-- to its own successor
theorem TInjSucc {n : N} : ¬ (n = s n) := by
  -- We proceed by induction on `n`
  induction n
  -- Base case
  intro h
  cases h
  -- Inductive step
  rename_i n hi
  intro h
  injection h with h
  exact hi h

-- ## Maximum
-- `Max (z, n) = n`
theorem TMaxzL : ∀ {n : N}, (maxi z n) = n := by
    intro n
    cases n
    -- z
    exact rfl
    -- s n
    exact rfl

-- `Max (n, z) = n`
theorem TMaxzR : ∀ {n : N}, (maxi n z) = n := by
    intro n
    cases n
    -- z
    exact rfl
    -- s n
    exact rfl

-- `Max (n, m) = Max (m, n)`
theorem TMaxComm : ∀ {n m : N}, (maxi n m) = (maxi m n) := by
  intro n m
  match n, m with
    | z, _ => rw [TMaxzL, TMaxzR]
    | _, z => rw [TMaxzL, TMaxzR]
    | (s n'), (s m') => rw [maxi, congrArg s (TMaxComm), maxi]

-- `Max (n, m) = n ∨ Max (n, m) = m`
theorem TMaxOut : ∀ {n m : N}, ((maxi n m) = n) ∨ ((maxi n m) = m) := by
  intro n m
  match n, m with
    | z, _ => exact Or.inr TMaxzL
    | _, z => exact Or.inl TMaxzR
    | (s n'), (s m') => match (@TMaxOut n' m') with
      | Or.inl h => exact Or.inl (congrArg s h)
      | Or.inr h => exact Or.inr (congrArg s h)

  -- `Max (n, n) = n`
  theorem TMaxIdpt : ∀ {n : N}, maxi n n = n := by
    intro n
    match (@TMaxOut n n) with
      | Or.inl h => exact h
      | Or.inr h => exact h

-- ## Minimum
-- `Min (z, n) = z`
theorem TMinzL : ∀ {n : N}, (mini z n) = z := by
    intro n
    cases n
    -- z
    exact rfl
    -- s n
    exact rfl

-- `Min (n, z) = z`
theorem TMinzR : ∀ {n : N}, (mini n z) = z := by
    intro n
    cases n
    -- z
    exact rfl
    -- s n
    exact rfl

-- `Min (n, m) = Min (m, n)`
theorem TMinComm : ∀ {n m : N}, (mini n m) = (mini m n) := by
  intro n m
  match n, m with
    | z, _ => rw [TMinzL, TMinzR]
    | _, z => rw [TMinzL, TMinzR]
    | (s n'), (s m') => rw [mini, congrArg s (TMinComm), mini]

-- `Min (n, m) = n ∨ Min (n, m) = m`
theorem TMinOut : ∀ {n m : N}, ((mini n m) = n) ∨ ((mini n m) = m) := by
  intro n m
  match n, m with
    | z, _ => exact Or.inl TMinzL
    | _, z => exact Or.inr TMinzR
    | (s n'), (s m') => match (@TMinOut n' m') with
      | Or.inl h => exact Or.inl (congrArg s h)
      | Or.inr h => exact Or.inr (congrArg s h)

-- `Min (n, n) = n`
theorem TMinIdpt : ∀ {n : N}, mini n n = n := by
  intro n
  match (@TMinOut n n) with
    | Or.inl h => exact h
    | Or.inr h => exact h

-- `Min (n, m) = Max (n, m) → n = m `
theorem TMinMaxEq : ∀ {n m : N}, mini n m = maxi n m → n = m := by
  intro n m h1
  cases n
  calc
    z = mini z m := TMinzL.symm
    _ = maxi z m := h1
    _ = m        := TMaxzL
  rename_i n'
  cases m
  calc
    n'.s = maxi n'.s z := TMaxzR.symm
    _    = mini n'.s z := h1.symm
    _    = z           := TMinzR
  rename_i m'
  apply congrArg
  injection h1 with h1
  exact TMinMaxEq h1

-- `Min (n, m) = n ↔ Max (n, m) = m`
theorem TMinMax : ∀ {n m : N}, mini n m = n ↔ maxi n m = m := by
  intro n m
  apply Iff.intro
  -- mini n m = n → maxi n m = m
  intro h
  cases (@TMaxOut n m)
  -- maxi n m = n
  rename_i h1
  have h2 : n = m := by
    apply TMinMaxEq
    exact h.trans (h1.symm)
  rw [h2]
  exact TMaxIdpt
  -- maxi n m = m
  rename_i h1
  exact h1
  -- maxi n m = m → mini n m = n
  intro h
  cases (@TMinOut n m)
  -- mini n m = n
  rename_i h1
  exact h1
  -- mini n m = m
  rename_i h1
  have h2 : n = m := by
    apply TMinMaxEq
    exact h1.trans (h.symm)
  rw [h2]
  exact TMinIdpt

-- ## Addition
-- `z` is a left identity for addition
theorem TAdd0L : ∀ {n : N}, z + n = n := by
  intro n
  exact rfl

-- `z` is a right identity for addition
theorem TAdd0R : ∀ {n : N}, n + z = n := by
  intro n
  induction n
  -- Base case
  exact rfl
  -- Inductive step
  rename_i n hi
  calc
    s n + z = s (n + z) := rfl
    _       = s n       := congrArg s hi

-- Addition of natural numbers
-- is commutative up to a successor
theorem TAddOne : ∀ {n m : N}, (s n) + m = n + (s m) := by
  intro n m
  induction n
  -- Base case
  exact rfl
  -- Inductive step
  rename_i n hi
  calc
    s (s n) + m = s (s n + m)   := rfl
    _           = s (n + s m)   := congrArg s hi
    _           = (s n) + (s m) := rfl

-- Addition is commutative
theorem TAddComm : ∀ {n m : N}, n + m = m + n := by
  intro n m
  induction n
  -- Base case
  calc
    z + m = m     := rfl
    _     = m + z := TAdd0R.symm
  -- Inductive step
  rename_i n hi
  calc
    (s n) + m = s (n + m) := rfl
    _         = s (m + n) := congrArg s hi
    _         = (s m) + n := rfl
    _         = m + (s n) := TAddOne

-- If the sum of two natural numbers is `z`,
-- then the first number must be `z`
theorem TAddZ : ∀ {n m : N}, n + m = z → n = z := by
  intro n m h
  cases n
  -- Case z
  exact rfl
  -- Case s n -- This case is impossible
  cases h

-- If the sum of two natural numbers is `z`,
-- then both numbers are `z`
theorem TAddZ2 : ∀ {n m : N}, n + m = z → (n = z) ∧ (m = z) := by
  intro n m h
  apply And.intro
  -- Left
  exact TAddZ h
  -- Right using commutativity
  rw [TAddComm] at h
  exact TAddZ h

-- Addition is associative
theorem TAddAss : ∀{n m p : N}, (n + m) + p = n + (m + p) := by
  intro n m p
  induction n
  -- Case z
  exact rfl
  -- Case s n
  rename_i n hi
  calc
    ((s n) + m) + p = (s (n + m)) + p := rfl
    _               = s ((n + m) + p) := rfl
    _               = s (n + (m + p)) := congrArg s hi
    _               = (s n) + (m + p) := rfl

-- `n` can never be equal to `n + s k`
theorem TAddSucc : ∀ {n k : N}, n = n + (s k) → False := by
  intro n k h
  induction n
  -- Case z
  cases h
  -- Case s n
  rename_i n hi
  have h1 : s n = s (n + (s k)) := by
    calc
      s n = s n + s k   := h
      _   = s (n + s k) := rfl
  injection h1 with h1
  exact hi h1

-- A number cannot be both ahead of and
-- behind another number by a positive amount
theorem TIncAdd : ∀ {n m k : N}, m = n + (s k) →  n = m + (s k) → False := by
  intro n m k h1 h2
  rw [h2, TAddAss] at h1
  exact (@TAddSucc m (k + s k)) h1

-- Right congruence of addition
theorem TAddCongR : ∀ {n m k : N}, m = k → n + m = n + k := by
  intro n m k h1
  rw [h1]

-- Left congruence of addition
theorem TAddCongL : ∀ {n m k : N}, m = k → m + n = k + n := by
  intro n m k h1
  rw [h1]

-- Addition on the left is cancellative
theorem TAddCancL : ∀ {n m k : N}, n + m = n + k → m = k := by
  intro n m k h
  induction n
  -- Case z
  exact h
  -- Case s n
  rename_i n hi
  have h1 : s (n + m) = s (n + k) := h
  injection h1 with h1
  exact hi h1

-- Addition on the right is cancellative
theorem TAddCancR : ∀ {n m k : N}, m + n = k + n → m = k := by
  intro n m k h
  have h1 : n + m = n + k := by
    calc
      n + m = m + n := TAddComm
      _     = k + n := h
      _     = n + k := TAddComm
  exact TAddCancL h1

-- Left cancellation property of addition with zero
theorem TAddCancLZ : ∀ {n m : N}, n + m = n → m = z := by
  intro n m h
  apply @TAddCancL n m z
  rw [h]
  exact TAdd0R.symm

-- Right cancellation property of addition with zero
theorem TAddCancRZ : ∀ {n m : N}, m + n = n → m = z := by
  intro n m h
  apply @TAddCancR n m z
  rw [h]
  exact TAdd0L

-- ## Multiplication
-- `z` is a left zero for multiplication
theorem TMult0L : ∀ {n : N}, z * n = z := by
  intro n
  exact rfl

-- `z` is a right zero for multiplication
theorem TMult0R : ∀ {n : N}, n * z = z := by
  intro n
  induction n
  -- Case z
  exact rfl
  -- Case s n
  rename_i n hi
  calc
    (s n) * z = n * z + z := rfl
    _         = z + z     := congrFun (congrArg Addition hi) z
    _         = z         := rfl

-- We introduce `one`
def one : N := s z

-- `one + n = s n`
theorem TOneAddR : ∀ {n : N}, one + n = s n := by
  intro n
  exact rfl

-- `n + one = s n`
theorem TOneAddL : ∀ {n : N}, n + one = s n := by
  intro n
  apply TAddComm

-- The different cases for two numbers adding to one
theorem TAddOneCases : ∀ {n m : N}, n + m = one → (n = z ∧ m = one) ∨ (n = one ∧ m = z) := by
  intro n m h
  cases n
  -- Case z
  apply Or.inl
  apply And.intro
  exact rfl
  exact h
  -- Case s n
  rename_i n
  injection h with h
  apply Or.inr
  apply And.intro
  rw [TAddZ h]
  exact rfl
  rw [TAddComm] at h
  exact TAddZ h

-- `one` is a left identity for multiplication
theorem TMult1L : ∀ {n : N}, one * n = n := by
  intro n
  exact rfl

-- `one` is a right identity for multiplication
theorem TMult1R : ∀ {n : N}, n * one = n := by
  intro n
  induction n
  -- Base case
  exact rfl
  -- Inductive step
  rename_i n hi
  calc
    s n * one = n * one + one := rfl
    _         = n + one       := congrFun (congrArg Addition hi) one
    _         = n + (s z)     := rfl
    _         = (s n) + z     := TAddOne.symm
    _         = s n           := TAdd0R

-- Multiplications is left distributive over addition
theorem TMultDistL : ∀ {n m k : N}, (n + m) * k = (n * k) + (m * k) := by
  intro n m k
  induction n
  -- Base case
  exact rfl
  -- Inductive step
  rename_i n hi
  calc
    ((s n) + m) * k = (s (n + m)) * k         := rfl
    _               = (n + m) * k + k         := rfl
    _               = (n * k) + (m * k) + k   := TAddCongL hi
    _               = (n * k) + ((m * k) + k) := TAddAss
    _               = (n * k) + (k + (m * k)) := TAddCongR TAddComm
    _               = (n * k) + k + (m * k)   := TAddAss.symm
    _               = ((s n) * k) + (m * k)   := rfl

-- Multiplications is right distributive over addition
theorem TMultDistR : ∀ {n m k : N}, n * (m + k) = (n * m) + (n * k) := by
  intro n m k
  induction n
  -- Base case
  exact rfl
  -- Inductive step
  rename_i n hi
  calc
    (s n) * (m + k) = n * (m + k) + (m + k)     := rfl
    _               = n * m + n * k + (m + k)   := congrFun (congrArg Addition hi) (m + k)
    _               = n * m + n * k + (k + m)   := TAddCongR TAddComm
    _               = n * m + (n * k + (k + m)) := TAddAss
    _               = n * m + (n * k + k + m)   := TAddCongR TAddAss.symm
    _               = n * m + (n * k + k) + m   := TAddAss.symm
    _               = n * m + ((n * k + k) + m) := TAddAss
    _               = n * m + (m + (n * k + k)) := TAddCongR TAddComm
    _               = n * m + (m + n * k + k)   := TAddCongR TAddAss.symm
    _               = n * m + (m + n * k) + k   := TAddAss.symm
    _               = n * m + m + n * k + k     := TAddCongL TAddAss.symm
    _               = (s n) * m + n * k + k     := rfl
    _               = (s n) * m + (n * k + k)   := TAddAss
    _               = (s n) * m + (s n) * k     := rfl

-- Multiplication is commutative
theorem TMultComm : ∀ {n m : N}, n * m = m * n := by
  intro n m
  induction n
  -- Base case
  calc
    z * m = z     := rfl
    _     = m * z := TMult0R.symm
  -- Inductive step
  rename_i n hi
  calc
    (s n) * m = n * m + m           := rfl
    _         = m * n + m           := TAddCongL hi
    _         = m + (m * n)         := TAddComm
    _         = (m * one) + (m * n) := TAddCongL (TMult1R.symm)
    _         = m * (one + n)       := TMultDistR.symm
    _         = m * (s n)           := rfl

-- If the product of two natural numbers is `z`,
-- then one of them must be `z`
theorem TMultZ : ∀ {n m : N}, n * m = z → (n = z) ∨ (m = z) := by
  intro n m h
  cases n
  -- Case z
  apply Or.inl
  exact rfl
  -- Case s n
  rename_i n
  apply Or.inr
  have h1 : (n * m = z) ∧ (m = z) := TAddZ2 h
  exact h1.right

-- Right congruence of multiplication
theorem TMultCongR : ∀ {n m k : N}, m = k → n * m = n * k := by
  intro n m k h1
  rw [h1]

-- Left congruence of addition
theorem TMultCongL : ∀ {n m k : N}, m = k → m * n = k * n := by
  intro n m k h1
  rw [h1]

-- Multiplication is associative
theorem TMultAss : ∀{n m p : N}, (n * m) * p = n * (m * p) := by
  intro n m p
  induction n
  -- Case z
  exact rfl
  -- Case s n
  rename_i n hi
  calc
    ((s n) * m) * p = (n * m + m) * p                 := rfl
    _               = ((n * m) * p) + m * p           := TMultDistL
    _               = (n * (m * p)) + m * p           := TAddCongL hi
    _               = (n * (m * p)) + (one * (m * p)) := TAddCongR TMult1L
    _               = (n + one) * (m * p)             := TMultDistL.symm
    _               = (s n) * (m * p)                 := TMultCongL TOneAddL

-- Fix points for multiplication
theorem TMultFix : ∀{n m : N}, n * m = n → n = z ∨ m = one := by
  intro n m h1
  cases m
  -- Case z
  apply Or.inl
  rw [TMult0R] at h1
  exact h1.symm
  -- Case s m
  rename_i m
  have h2 : n * m + n = n := by
    calc
      n * m + n = n * m + n * one := by rw [TMult1R]
      _         = n * (m + one)   := TMultDistR.symm
      _         = n * (s m)       := by rw [TOneAddL]
      _         = n               := h1
  have h3 : n * m = z := TAddCancRZ h2
  apply Or.elim (TMultZ h3)
  -- Case Left
  intro h4
  exact Or.inl h4
  -- Case Right
  intro h5
  apply Or.inr
  rw [h5]
  exact rfl

-- `one` is the unique idempotent for multiplication
theorem TMultOne : ∀ {n m : N}, n * m = one ↔ (n = one ∧ m = one) := by
  intro n m
  apply Iff.intro
  -- n * m = one → n = one ∧ m = one
  intro h1
  induction n
  -- Case z
  rw [TMult0L] at h1
  cases h1
  -- Case s n
  rename_i n hi
  apply Or.elim (TAddOneCases h1)
  -- Case Left
  intro ⟨h3, h4⟩
  apply Or.elim (TMultZ h3)
  -- Case Left
  intro h5
  rw [h5]
  exact And.intro rfl h4
  -- Case Right (impossible)
  intro h5
  rw [h5] at h4
  cases h4
  -- Case Right (impossible)
  intro ⟨h2, h3⟩
  have h4 : m = one := (hi h2).right
  rw [h4] at h3
  cases h3
  -- n = one ∧ m = one → n * m = one
  intro ⟨h3, h4⟩
  rw [h3, h4, TMult1L]

end a06Exercises
