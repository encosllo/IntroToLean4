-- # Equivalences
import a05Functions
import a07Choice
import a08Subtypes
import a09Relations
open Inj
open Surj
open Bij
open Relations
open Diagonal

namespace Equivalence
-- ## Equivalence relations
-- An **Equivalence** relation is a relation that is
-- `Reflexive`, `Symmetric` and `Transitive`
-- This is already implemented as `Equivalence`
#check Equivalence
#print Equivalence

-- ### Examples (from a08Relations)
-- The diagonal relation is an equivalence relation
theorem TDiagEqv {A : Type} : Equivalence (@diag A) := {
  refl  := by
    intro a
    exact TDiagRefl
  symm  := by
    intro a1 a2
    exact TDiagSymm
  trans := by
    intro a1 a2 a3
    exact TDiagTrans
}

-- The total relation is an equivalence relation
theorem TTotalEqv {A : Type} : Equivalence (@total A) := {
  refl  := by
    intro _
    exact trivial
  symm  := by
    intro a1 a2 _
    exact trivial
  trans := by
    intro a1 a2 a3 _ _
    exact trivial
}

-- ## The Kernel of a function
-- We introduce the kernel of a function
def Ker {A B : Type} (f : A → B) : A → A → Prop := by
  intro a1 a2
  exact f a1 = f a2

-- The kernel of a function is an equivalence relation
theorem TKerEqv {A B : Type} {f : A → B} : Equivalence (Ker f) := {
  refl  := by
    intro a
    exact rfl
  symm  := by
    intro a1 a2 h1
    exact h1.symm
  trans := by
    intro a1 a2 a3 h1 h2
    exact h1.trans h2
}
end Equivalence

namespace Eqvgen
-- ## Equivalence generated by a relation
-- The equivalence generated by a relation `R` is
-- the smallest equivalence relation that contains `R`

inductive Eqvgen {A : Type} (R : A → A → Prop) : A → A → Prop where
  | base : ∀ {a1 a2 : A}, (R a1 a2 → Eqvgen R a1 a2)
  | refl : ∀ (a : A), Eqvgen R a a
  | symm : ∀ {a1 a2 : A}, Eqvgen R a1 a2 → Eqvgen R a2 a1
  | trans : ∀ {a1 a2 a3 : A}, (Eqvgen R a1 a2) → (Eqvgen R a2 a3) → (Eqvgen R a1 a3)

-- The equivalence generated by a relation is an equivalence relation
theorem TEqvgen {A : Type} (R : A → A → Prop) : Equivalence (Eqvgen R) := {
  refl  := Eqvgen.refl
  symm  := Eqvgen.symm
  trans := Eqvgen.trans
}

end Eqvgen



namespace Quotient
--https://leanprover-community.github.io/mathlib4_docs/Init/Core.html#Setoid
open Equivalence

-- ## Setoid
-- A **Setoid** is a type class that encapsulates
-- an equivalence relation on a given type.
#print Setoid

variable (A : Type)
variable (S : Setoid A)

-- Elements of type `Setoid A` have two fields `r`,
-- the equivalence relation, and `iseqv`, a proof
-- of `r` being an equivalence relation
#check S.r
#check S.iseqv

/-
-- ### Equality of setoids
-- Two setoids are equal if if and only if
-- their associated relations are equal
theorem TEqSetoid {A : Type} {S T : Setoid A} : S = T ↔ S.r = T.r := by
  apply Iff.intro
  -- S = T → Setoid.r = Setoid.r
  intro h
  rw [h]
  -- Setoid.r = Setoid.r → S = T
  intro h
  cases S
  cases T
  simp at *
  congr
-/

-- ### Examples of Setoids
-- #### The diagonal Setoid
instance DiagSetoid {A : Type} : Setoid A := {
  r     := @diag A
  iseqv := TDiagEqv
}

-- #### The total Setoid
instance TotalSetoid {A : Type} : Setoid A := {
  r     := @total A
  iseqv := TTotalEqv
}

-- #### The Kernel Setoid
instance KerSetoid {A B : Type} (f : A → B) : Setoid A := {
  r     := Ker f
  iseqv := TKerEqv
}

-- ## Quotients
-- Setoids are used to make quotients
#print Quot
#print Quotient

-- Note that for a type `A` and `S : Setoid A`,
-- `Quotient S` is a type
#check Quotient S

-- ### Examples of Quotients
-- #### The diagonal quotient `A/diag`
def QDiag {A : Type} := Quotient (@DiagSetoid A)

-- #### The total quotient `A/total`
def Qtotal {A : Type} := Quotient (@TotalSetoid A)

-- #### The total quotient `A/Ker f`
def QKer {A B : Type} (f : A → B) := Quotient (KerSetoid f)

-- ### Elements of type `Quotient S`
-- To make an element of type `Quotient S`
-- we use the `Quotient.mk` keyword
-- This returns the class of `a` with respect to
-- the relation `S.r`, that is, all the elements of
-- of type `A` that are `S.r`-related with `a`
variable (a : A)
#check Quotient.mk S a

-- This in particular allows us to define the projection
-- function from a type `A` to its quotient
def pr {A : Type} (S : Setoid A) : A → Quotient S := by
  intro a
  exact Quotient.mk S a

-- All the elements of type `Quotient S`
-- are of this form, that is we can always find a
-- representative. This is done using `Quotient.exists_rep`
#check Quotient.exists_rep

-- As a consequence, the projection function is surjective
theorem TprSurj {A : Type} (S : Setoid A) : surjective (pr S) := by
  intro q
  apply Quotient.exists_rep

-- Two classes are equal if, and only if,
-- their representatives are related. This double implication
-- is proven using the `Quotient.exact` and `Quotient.sound` keywords
theorem TEqQuotient {A : Type} {S : Setoid A} {a1 a2 : A} : (Quotient.mk S a1 = Quotient.mk S a2) ↔ (S.r a1 a2) := by
  apply Iff.intro
  -- Quotient.mk S a1 = Quotient.mk S a2 → Setoid.r a1 a2
  apply Quotient.exact
  -- Setoid.r a1 a2 → Quotient.mk S a1 = Quotient.mk S a2
  apply Quotient.sound

-- ## Astriction
-- The astriction of a function
def ast {A B : Type} {S : Setoid B} (f : A → B) : A → Quotient S := by
  intro a
  exact Quotient.mk S (f a)

-- ## Coastriction
-- Coastriction of a function
-- For this we use `Quotient.lift`
def coast {A B : Type} {R : Setoid A} (f : A → B) (h : ∀ (a1 a2 : A), R.r a1 a2 → (Ker f) a1 a2) : Quotient R → B := by
  apply Quotient.lift f
  intro a1 a2 h1
  exact (h a1 a2) h1

-- ## Biastriction
-- Biastriction of a function `biast = coast ∘ ast`
def biast {A B : Type} {R : Setoid A} {S : Setoid B} (f : A → B) (h : ∀ (a1 a2 : A), R.r a1 a2 → S.r (f a1) (f a2)) : Quotient R → Quotient S := by
  apply coast (ast f)
  intro a1 a2 hR
  specialize h a1 a2
  apply Quotient.sound
  exact h hR

-- In particular, for two setoids `R1` and `R2` on `A`
-- satisfying that `R1.r` implies `R2.r` then there
-- exists a way of transforming elements
-- of type `Quotient R1` into elements of `Quotient R2`
-- For this we will biastrict the identity
def QuottoQuot {A : Type} {R1 R2 : Setoid A} (h : ∀ (a1 a2 : A), R1.r a1 a2 → R2.r a1 a2) : Quotient R1 → Quotient R2 := biast id h

end Quotient

namespace Coequalizers
open Eqvgen Quotient
-- ## Coequalizers
-- The coequalizer of two functions `f g : A → B`
-- is the type of elements `b : B` up to the fact that elements
-- `f a` and `g a` are considered to be equal
-- It is a quotient type of `B`

-- We define the relation on `B` relating elements of the form
-- `f a` and `g a` for some `a : A`
def CoeqRel {A B : Type} (f g : A → B) : B → B → Prop := by
  intro b1 b2
  exact ∃ (a : A), (f a = b1) ∧ (g a = b2)

-- We next consider the equivalence relation
-- generated by the previous relation
def CoeqEqv {A B : Type} (f g : A → B) := Eqvgen (CoeqRel f g)

-- ## The Coequalizer Setoid
-- This is the corresponding setoid
instance CoeqSetoid {A B : Type} (f g : A → B): Setoid B := {
  r     := CoeqEqv f g
  iseqv := TEqvgen (CoeqRel f g)
}

-- ## The coequalizer `Coeq f g`
-- We finally consider the quotient `Coeq f g`
def Coeq {A B : Type} (f g : A → B) : Type := Quotient (CoeqSetoid f g)

-- The projection function from `B` to the coequalizer
def prCoeq {A B : Type} (f g : A → B) : B → Coeq f g := @pr B (CoeqSetoid f g)

-- The projection function satisfies that `(prCoeq f g) ∘ f = (prCoeq f g) ∘ g`
theorem TCoeqPr {A B : Type} (f g : A → B) : (prCoeq f g) ∘ f = (prCoeq f g) ∘ g := by
  apply funext
  intro a
  apply Quotient.sound
  apply Eqvgen.base
  apply Exists.intro a
  apply And.intro
  exact rfl
  exact rfl

-- Universal property of the coequalizer
-- If there is another function `h : B → C` satisfying
-- `h ∘ f = h ∘ g`, then there exists a function `u : Coeq f g → C`
def u {A B C : Type} {f g : A → B} {h : B → C} (h1 : h ∘ f = h ∘ g) : Coeq f g → C := by
  apply Quotient.lift h
  intro b1 b2 h2
  induction h2
  -- Base case
  rename_i c1 c2 h2
  apply Exists.elim h2
  intro a ⟨h2, h3⟩
  calc
    h c1  = h (f a)   := congrArg h (h2.symm)
    _     = (h ∘ f) a := rfl
    _     = (h ∘ g) a := congrFun h1 a
    _     = h (g a)   := rfl
    _     = h c2      := congrArg h h3
  -- Rfl Case
  rename_i c
  exact rfl
  -- Symm Case
  rename_i c1 c2 _ h3
  exact h3.symm
  -- Trans Case
  rename_i c1 c2 c3 _ _ h4 h5
  exact h4.trans h5

-- The function `u` satisfies that `u ∘ prCoeq f g = h`
theorem TCoeqPrEq {A B C : Type} {f g : A → B} {h : B → C} (h1 : h ∘ f = h ∘ g) : (u h1) ∘ (prCoeq f g) = h := by
  apply funext
  intro b
  exact rfl

-- The function `u` is unique in the sense that if there is another function
-- `v : Coeq f g → C` satisfying `v ∘ (prCoeq f g) = h`, then `v = u`
theorem TCoeqUni {A B C : Type} {f g : A → B} {h : B → C} (h1 : h ∘ f = h ∘ g) (v : Coeq f g → C) (h2 : v ∘ (prCoeq f g) = h) : v = u h1 := by
  apply funext
  intro z
  have h3 : ∃ (b : B), Quotient.mk (CoeqSetoid f g) b = z := Quotient.exists_rep z
  apply Exists.elim h3
  intro b h4
  calc
    v z = v (prCoeq f g b)                        := congrArg v (h4.symm)
    _   = (v ∘ prCoeq f g) b                      := rfl
    _   = h b                                     := congrFun h2 b
    _   = ((u h1) ∘ (prCoeq f g)) b               := congrFun (TCoeqPrEq h1) b
    _   = (u h1) (prCoeq f g b)                   := rfl
    _   = (u h1) z                                := congrArg (u h1) (h4)


namespace a10ExercisesCoeq
-- The function `prCoeq` is an epimorphism
theorem TprCoeqEpi {A B : Type} {f g : A → B} : epimorphism (prCoeq f g) := by
  intro C v1 v2 h1
  apply funext
  intro z
  have h3 : ∃ (b : B), Quotient.mk (CoeqSetoid f g) b = z := Quotient.exists_rep z
  apply Exists.elim h3
  intro b h4
  calc
    v1 z  = v1 (prCoeq f g b)   := congrArg v1 (h4.symm)
    _     = (v1 ∘ prCoeq f g) b := rfl
    _     = (v2 ∘ prCoeq f g) b := congrFun h1 b
    _     = v2 (prCoeq f g b)   := rfl
    _     = v2 z                := congrArg v2 (h4)

-- A monic `prCoeq` is an isomorphism
theorem TprCoeqMon {A B : Type} {f g : A → B} : monomorphism (prCoeq f g) → isomorphism (prCoeq f g) := by
  intro h1
  have h2 : f = g := by
    apply @h1 A f g
    exact TCoeqPr f g
  let fu : Coeq f g → B := by
    apply @u A B B f g id
    exact h2
  apply Exists.intro fu
  apply And.intro
  -- fu ∘ prCoeq f g = id
  apply TCoeqPrEq
  -- prCoeq f g ∘ fu = id
  funext z
  have h3 : ∃ (b : B), Quotient.mk (CoeqSetoid f g) b = z := Quotient.exists_rep z
  apply Exists.elim h3
  intro b h4
  rw [h4.symm]
  calc
    (prCoeq f g ∘ fu) (Quotient.mk (CoeqSetoid f g) b)  = (prCoeq f g) ((fu ∘ prCoeq f g) b)  := congrArg (prCoeq f g) rfl
    _                                                   = (prCoeq f g) (id b)                 := congrArg (prCoeq f g) rfl
    _                                                   = (prCoeq f g) b                      := rfl
    _                                                   = id (Quotient.mk (CoeqSetoid f g) b) := rfl

end a10ExercisesCoeq
end Coequalizers


namespace a10Exercises
open a06Exercises
open Equivalence
open Quotient

-- ## Exercises
-- The meet of two equivalence relations is
-- an equivalence relation
theorem TMeetEqv {A : Type} {R S : A → A → Prop} (hR : Equivalence R) (hS : Equivalence S) : Equivalence (R ∧ S) := {
  refl := by
    intro a
    exact And.intro (hR.refl a) (hS.refl a)
  symm := by
    intro a1 a2 ⟨h1, h2⟩
    exact And.intro (hR.symm h1) (hS.symm h2)
  trans := by
    intro a1 a2 a3 ⟨h1, h2⟩ ⟨h3, h4⟩
    exact And.intro (hR.trans h1 h3) (hS.trans h2 h4)
}

-- If two setoids have equivalent underlying relations
-- then the corresponding quotient types are equal
theorem TEqQuotype {A : Type} {R1 R2 : Setoid A}
(h : ∀ (a1 a2 : A), R1.r a1 a2 ↔ R2.r a1 a2) : Quotient R1 = Quotient R2 := by
  have h1 : R1 = R2 := by
    cases R1
    rename_i R1r R1rEqv
    cases R2
    rename_i R2r R2rEqv
    congr
    funext a1 a2
    apply propext
    exact h a1 a2
  rw [h1]

-- Universal property of quotient types
-- Ker (pr) = Setoid.r
theorem TUPQuot {A : Type} {R : Setoid A} : Ker (pr R) = R.r := by
  funext a1 a2
  apply propext
  apply Iff.intro
  -- Ker (pr R) a1 a2 → Setoid.r a1 a2
  apply Quotient.exact
  -- Setoid.r a1 a2 → Ker (pr R) a1 a2
  apply Quotient.sound

-- Astriction `ast f = pr ∘ f`
theorem TAst {A B : Type} {f : A → B} {S : Setoid B}: (@ast A B S f) = (@pr B S) ∘ f := by
  exact rfl

-- Universal property of the coastriction
-- `f = coast ∘ pr`
theorem TUPCoast {A B : Type} {R : Setoid A} {f : A → B} (h : ∀ (a1 a2 : A), R.r a1 a2 → (Ker f) a1 a2) : f =  (coast f h) ∘ (@pr A R) := by
  exact rfl

-- Unicity
theorem TUPCoastUn {A B : Type} {R : Setoid A} {f : A → B} (h : ∀ (a1 a2 : A), R.r a1 a2 → (Ker f) a1 a2) (g : Quotient R → B) (h1 : f = g ∘ (@pr A R)) : (coast f h) = g := by
  apply funext
  intro q
  have ha : ∃ (a : A), Quotient.mk R a = q := Quotient.exists_rep q
  apply Exists.elim ha
  intro a haq
  rw [haq.symm]
  calc
    coast f h (Quotient.mk R a) = ((coast f h) ∘ (@pr A R)) a := by exact rfl
    _                           = f a                         := by exact congrFun (TUPCoast h) a
    _                           = (g ∘ (@pr A R)) a           := by exact congrFun h1 a
    _                           = g (Quotient.mk R a)         := by exact rfl

-- ## Bijective types
-- We introduce the subtype of all
-- isomorphisms from a type `A` to a type `B`
def Iso (A B : Type) := {f : A → B // isomorphism f}

-- We say that two types `A` and `B` are isomorphic if
-- there is some isomorphism from `A` to `B`
def Isomorphic : Type → Type → Prop := by
  intro A B
  exact Nonempty (Iso A B)

-- Notation for Isomorphic types (`\cong`)
notation : 65 lhs:65 " ≅ " rhs:66 => Isomorphic lhs rhs

-- Being isomorphic is an equivalence relation
theorem TIsoEqv : Equivalence Isomorphic := {
  refl := by
    intro A
    apply Nonempty.intro
    apply Subtype.mk (@id A)
    exact TIdMon A
  symm := by
    intro A B h
    let f : Iso A B := Classical.choice h
    apply Exists.elim f.property
    intro g ⟨h1, h2⟩
    apply Nonempty.intro
    apply Subtype.mk g
    apply Exists.intro f.val
    apply And.intro
    exact h2
    exact h1
  trans := by
    intro A B C h1 h2
    let f : Iso A B := Classical.choice h1
    apply Exists.elim f.property
    intro g ⟨h3, h4⟩
    let h : Iso B C := Classical.choice h2
    apply Exists.elim h.property
    intro i ⟨h5, h6⟩
    apply Nonempty.intro
    apply Subtype.mk (h.val ∘ f.val)
    apply Exists.intro (g ∘ i)
    apply And.intro
    calc
      (g ∘ i) ∘ h.val ∘ f.val = g ∘ (i ∘ h.val) ∘ f.val := by exact rfl
      _                       = g ∘ id ∘ f.val          := by rw [h5]
      _                       = g ∘ f.val               := by exact rfl
      _                       = id                      := by rw [h3]
    calc
      (h.val ∘ f.val) ∘ g ∘ i = h.val ∘ (f.val ∘ g) ∘ i := by exact rfl
      _                       = h.val ∘ id ∘ i          := by rw [h4]
      _                       = h.val ∘ i               := by exact rfl
      _                       = id                      := by rw [h6]
}

-- Under `Classical.choice`, every type `A` is isomorphic
-- to `A/diag`
theorem TDiag {A : Type} : A ≅ @QDiag A := by
  apply Nonempty.intro
  apply Subtype.mk (@pr A DiagSetoid)
  let g : (@QDiag A) → A := by
    apply (coast (@id A))
    intro a1 a2 h
    exact h
  apply Exists.intro g
  apply And.intro
  -- Left
  exact rfl
  -- Right
  funext q
  let a : A := Classical.choose (Quotient.exists_rep q)
  have hq : Quotient.mk (DiagSetoid) a = q := Classical.choose_spec (Quotient.exists_rep q)
  rw [hq.symm]
  apply Quotient.sound
  exact rfl

-- Under `Classical.choice`, if two types `A` and `B` are
-- `Nonempty`, then `A/Total` and `B/Total` are isomorphic
theorem TTotal {A B : Type} (hA : Nonempty A) (hB : Nonempty B) : @Qtotal A ≅ @Qtotal B := by
  apply Nonempty.intro
  let f : A → B := by
    intro _
    exact Classical.choice hB
  let fb : @Qtotal A → @Qtotal B := by
    apply biast f
    intro a1 a2 _
    exact trivial
  let g : B → A := by
    intro _
    exact Classical.choice hA
  let gb : @Qtotal B → @Qtotal A := by
    apply biast g
    intro b1 b2 _
    exact trivial
  apply Subtype.mk fb
  apply Exists.intro gb
  apply And.intro
  -- Left
  funext q
  let a : A := Classical.choose (Quotient.exists_rep q)
  have hq : Quotient.mk (TotalSetoid) a = q := Classical.choose_spec (Quotient.exists_rep q)
  rw [hq.symm]
  apply Quotient.sound
  exact trivial
  -- Right
  funext q
  let b : B := Classical.choose (Quotient.exists_rep q)
  have hq : Quotient.mk (TotalSetoid) b = q := Classical.choose_spec (Quotient.exists_rep q)
  rw [hq.symm]
  apply Quotient.sound
  exact trivial

-- Under `Classical.choice`, for every function `f : A → B`
-- the quotient `A/Ker f` is isomorphic to `Im f`
theorem TKerIm {A B : Type} (f : A → B) : QKer f ≅ Im f := by
  let fe : A → Im f := by
    apply correst f
    intro b
    exact b.property
  let fb : QKer f → Im f := by
    apply coast fe
    intro a1 a2 h
    apply Subtype.eq
    exact h
  apply Nonempty.intro
  apply Subtype.mk fb
  apply TCarBijIso.mp
  apply And.intro
  -- Injective
  intro q1 q2 h1
  let a1 : A := Classical.choose (Quotient.exists_rep q1)
  have hq1 : Quotient.mk (KerSetoid f) a1 = q1 := Classical.choose_spec (Quotient.exists_rep q1)
  let a2 : A := Classical.choose (Quotient.exists_rep q2)
  have hq2 : Quotient.mk (KerSetoid f) a2 = q2 := Classical.choose_spec (Quotient.exists_rep q2)
  rw [hq1.symm, hq2.symm] at h1
  rw [hq1.symm, hq2.symm]
  apply Quotient.sound
  have h3 : f a1 = f a2 := by
    calc
      f a1 = (fe a1).val := rfl
      _    = (fe a2).val := by exact congrArg Subtype.val h1
      _    = f a2        := rfl
  exact h3
  -- Surjective
  intro b
  cases b.property
  rename_i a h2
  apply Exists.intro (Quotient.mk (KerSetoid f) a)
  apply Subtype.eq
  exact h2

end a10Exercises
